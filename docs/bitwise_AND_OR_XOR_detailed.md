# 按位与、按位或、按位异或（详细版）

本文中，`a` 和 `b` 都是 `int` 类型整数，Python 默认指 Python 3，Processing 默认指 Processing 4。我没有测试过每一个版本，不保证文中的细节都适用于所有的版本。

## 目录

- [按位与](#按位与)
  - [一位二进制数按位与](#一位二进制数按位与)
  - [多位二进制数按位与](#多位二进制数按位与)
  - [如果用int，32位补码够用了](#如果用int，32位补码够用了)
- [按位或](#按位或)
  - [一位二进制数按位或](#一位二进制数按位或)
  - [多位二进制数按位或](#多位二进制数按位或)
- [按位异或](#按位异或)
  - [一位二进制数按位异或](#一位二进制数按位异或)
  - [多位二进制数按位异或](#多位二进制数按位异或)

## 按位与

符号：`&`

使用方式：`a & b`

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位都是 `1`，置 `1`，如果有 `0`，置 `0`。  

- 对有符号二进制数，按照**补码**参与运算，结果也是**补码**（**大坑警告！**）。  

### 一位二进制数按位与

0 & 0 = 0  
0 & 1 = 0  
1 & 0 = 0  
1 & 1 = 1  

简记：**全1得1，有0得0**

（声明：不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 & 0 =", 0 & 0);
println("0 & 1 =", 0 & 1);
println("1 & 0 =", 1 & 0);
println("1 & 1 =", 1 & 1);
```

预期输出应该与上述规则一样：

```
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1
```

### 多位二进制数按位与

**先转成补码，再从最低位开始，逐位求与。**

要求补码，一般先求**原码**，求原码的方式是：指定 m 位，先把数值部分转二进制，不足部分高位补 `0` 到 m-1 位，再确定符号位，正数是 `0` 负数是 `1`，加到最左边。

接着根据原码求补码：

- 对于正数，补码与原码相同。
- 对于负数，把原码的数值部分逐位取反加1。

然后才是从最低位开始逐位求与，注意对齐。

最后还要转回原数值：

如果符号位是0，直接转十进制即可；

如果符号位是1，与求补码类似，除了这一位以外，其余再逐位取反加1，得到原码，再把其余部分转十进制，符号位的 `1` 换成负号即可。

只有一个例外：符号位 1 其余全 0，则无原码，而且对应十进制数值等于 -2^(m-1)。

同时剩下一个疑问：m 取多少合适？

在不清楚用多少位补码的情况下，姑且按照数值大的确定补码，先保证位数够用。

例：计算 `11 & 5`。

转二进制补码：

11 是正数，用 4 位二进制数 `1011` 表示， 符号位 `0`，其余位不变，补码是 `01011`；

5 也是正数，二进制 `101`，只有 3 位，位数不够，先补一个 `0` 得到 `0101`，后续同理，得到补码 `00101`。

再计算：

`01011 & 00101 = 00001` （存疑？）

结果的符号位是 `0`，直接把数值部分转十进制即可，得到 1。

于是 `11 & 5 = 1`。

用代码计算一下：

```Processing
println(11&5);
```

查看控制台的输出，是 `1`。

也许你会说：直接转二进制，逐位求与，再转回十进制不一样吗？反正不足补 `0`：

`1011 & 0101 = 0001`

于是得到 1。

对正数，补码与原码相同，而且无论按位与、按位或还是按位异或，高位的 `0` 都不会影响结果。

但是对于负数就不可以，只能老老实实转补码计算。

例：计算 `11 & -5`。

转成补码······

问题是 -5 的补码是多少？有几位？

11 的二进制表示就有 4 位，加上一位 `0` 就有 5 位，为了保证位数够用，-5 的补码最少要有 5 位。

假设用 5 位有符号二进制数，用 `10101` 表示 -5，那么其补码就是 `11011`。

`01011 & 11011 = 01011 (?)` （注意这里存疑）

于是 `11 & -5 = 11`。

用代码计算一下：

```Processing
println(11&-5);
```

输出是 `11`，表明 5 位够了。

如果你忘记把负数转换成补码就可能得到这个结果：

`11 & -5 = 01011 & 10101 = 00001 = 1`

明显不对！而且你可能抓破头皮也找不出错在哪里。这就是最坑人的地方：

**计算机里面的数字按照补码参与位运算，结果也是补码**。

而且如果你在求十进制数 11 的二进制的时候，不小心多写了一位，把 `1011` 写成了 `11011`，那么 -5 的补码也不得不多用一位，变成了6位有符号二进制数补码：

`110101`

那么计算结果：

`011011 & 111011 = 011011`

即 `27 & -5`，结果 27，变大了不少。

用代码验证：

```Processing
println(0b11011 & -0b101, 27&-5);
```

输出 `27 27`。

忘记用补码运算，则有可能得到 `27 & -5 = 011011 & 100101 = 000001 = 1`，更离谱了。

那么有没有可能多补几个 `0` 就算出不同的结果？要一直补 `0` 补下去吗？有不用老是补 `0` 的方式吗？

### 如果用int，32位补码够用了

其实用 32 位补码就可以一步到位，因为 `int` 类型整数默认 32 位有符号二进制数，也不需要补更多 `0` 了。  

之前的“一位二进制数”和“多位二进制数”只是为了便于阅读人为分出来的，实际上计算机里用了多少位二进制数来表示，就是多少位二进制数，而且一般都是最坑人的补码。

于是一个小小的只有两个字符的 -5，其补码有整整 32 个字符。

为了便于阅读，每 4 位用空格分开，下同：
```
1111 1111 1111 1111 1111 1111 1111 1011
```
类似的，27 的补码：
```
0000 0000 0000 0000 0000 0000 0001 1011
```
于是 `27 & -5` 实际上计算的是：
```
  1111 1111 1111 1111 1111 1111 1111 1011
& 0000 0000 0000 0000 0000 0000 0001 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0001 1011
```
得到正数，原码与补码相同，从而结果还是 27。  

这里为了书写方便，就仿照一般竖式计算加减乘法的方式这样写，只是更换了运算符，运算规则，以及使用的是二进制数而不是十进制数，以及中间每四位就留出空格便于对齐每一位。我没查过这种写法是否有人使用过。

同时提醒一句，如果你还想模仿这种书写方式，为了与其他字符区分，可以使用'bitand'、'bitor'、'bitxor'或者汉字“位与”、“位或”、“位异或”：

`27 & -5`

```
       1111 1111 1111 1111 1111 1111 1111 1011
bitand 0000 0000 0000 0000 0000 0000 0001 1011
----------------------------------------------
       0000 0000 0000 0000 0000 0000 0001 1011
```

```
    1111 1111 1111 1111 1111 1111 1111 1011
位与 0000 0000 0000 0000 0000 0000 0001 1011
-------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 1011
```

Markdown 里的字符一般足以区分，故可以接着使用 `&`、`|`、`^` 等符号，看起来还简洁一点。

类似地，`11 & -5`：
```
  1111 1111 1111 1111 1111 1111 1111 1011
& 0000 0000 0000 0000 0000 0000 0000 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1011
```
结果是 11。

`11 & 5`：

```
  0000 0000 0000 0000 0000 0000 0000 0101
& 0000 0000 0000 0000 0000 0000 0000 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 0001
```

结果还是 1，与之前计算的一致。  

甚至可以求一下 `-11 & -5`：
```
  1111 1111 1111 1111 1111 1111 1111 0101
& 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0001
```
得到 -15。  

不过一般列出完整的 32 位补码，工作量确实有点大，也许你会忽略打头的 `0`，反正不足用 `0` 补齐嘛······  

但是隐藏的大坑就在这里：**由于计算机里的数是补码，所有负数的二进制表示都是以 `1` 开头的，不足位也都是 `1`。**所以遇到负数还能省略高位吗？能，但是默认不再是 `0` 而是 `1`。

简记：**为了避免出错，在用补码计算位运算省略高位的时候，符号位是什么，省略的就是什么，补齐就要用什么。即正数默认高位 `0`，负数默认高位 `1`，如果位数不够，正数用 `0` 补齐，负数用 `1` 补齐。**

这样不仅不用补那么多个 `0` 了，还有一个好处：如果用 Python 计算位运算，在省略高位数字的情况下，就不用费尽心思考虑到底要用多少位补码才不会出错了。毕竟 Python 里面 `-11&-5` 的结果也是（用补码求出的） -15。

## 按位或

符号：`|`

使用方式：`a | b`  

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位有1，置1，如果都是0，置0。  

- 对有符号二进制数，按照补码参与运算，结果也是补码。

### 一位二进制数按位或

0 | 0 = 0  
0 | 1 = 1  
1 | 0 = 1  
1 | 1 = 1  

简记：**有1得1，全0得0**

（同理，不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 | 0 =", 0 | 0);
println("0 | 1 =", 0 | 1);
println("1 | 0 =", 1 | 0);
println("1 | 1 =", 1 | 1);
```

预期输出应该与上述规则一样：

```
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1
```

### 多位二进制数按位或

**先转成补码，再从最低位开始，逐位求或**。

例如：

11 | 5 = 15  
11 | -5 = -5  
-11 | 5 = -11  
-11 | -5 = -1  

展开成32位补码：

```
11 | 5
  0000 0000 0000 0000 0000 0000 0000 1011
| 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1111
得到 11
```

```
11 | -5
  0000 0000 0000 0000 0000 0000 0000 1011
| 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 1011
得到 -5
```

```
-11 | 5
  1111 1111 1111 1111 1111 1111 1111 0101
| 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0101
得到 -11
```

```
-11 | -5
  1111 1111 1111 1111 1111 1111 1111 0101
| 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 1111
得到 -1
```

用以下代码验证一下：

```Processing
println("11 | 5 =", 11 | 5);
println("11 | -5 =", 11 | -5);
println("-11 | 5 =", -11 | 5);
println("-11 | -5 =", -11 | -5);
```

预期输出：
```
11 | 5 = 15
11 | -5 = -5
-11 | 5 = -11
-11 | -5 = -1
```

###

## 按位异或

符号：`^` 

使用方式：`a ^ b`

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位不同，置1，如果相同0，置0。  

- 对有符号二进制数，按照补码参与运算，结果也是补码。

### 一位二进制数按位异或

0 ^ 0 = 0  
0 ^ 1 = 1  
1 ^ 0 = 1  
1 ^ 1 = 0  

简记：**不同得1，相同得0**

（同理，不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 ^ 0 =", 0 ^ 0);
println("0 ^ 1 =", 0 ^ 1);
println("1 ^ 0 =", 1 ^ 0);
println("1 ^ 1 =", 1 ^ 1);
```

预期输出应该与上述规则一样：

```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

### 多位二进制数按位异或

**先转成补码，再从最低位开始，逐位求异或**。

还是之前的例子，只不过换成异或：

11 ^ 5 = 14  
11 ^ -5 = -16  
-11 ^ 5 = -16  
-11 ^ -5 = 14  

展开成32位补码：

```
11 ^ 5
  0000 0000 0000 0000 0000 0000 0000 1011
^ 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1110
得到 14
```

```
11 ^ -5
  0000 0000 0000 0000 0000 0000 0000 1011
^ 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0000
得到 -16
```

```
-11 ^ 5
  1111 1111 1111 1111 1111 1111 1111 0101
^ 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0000
得到 -16
```

```
-11 ^ -5
  1111 1111 1111 1111 1111 1111 1111 0101
^ 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1110
得到 14
```

用以下代码验证一下：

```Processing
println("11 ^ 5 =", 11 ^ 5);
println("11 ^ -5 =", 11 ^ -5);
println("-11 ^ 5 =", -11 ^ 5);
println("-11 ^ -5 =", -11 ^ -5);
```

预期输出：

```
11 ^ 5 = 14
11 ^ -5 = -16
-11 ^ 5 = -16
-11 ^ -5 = 14
```
