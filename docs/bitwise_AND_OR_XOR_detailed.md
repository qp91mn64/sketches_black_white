# 按位与、按位或、按位异或（详细版）

本文中，`a` 和 `b` 都是 `int` 类型整数，Python 默认指 Python 3，Processing 默认指 Processing 4。我没有测试过每一个版本，不保证文中的细节都适用于所有的版本。

## 目录

- [按位与](#按位与)
  - [一位二进制数按位与](#一位二进制数按位与)
  - [多位二进制数按位与](#多位二进制数按位与)
  - [32位补码够用了](#32位补码够用了)
- [按位或](#按位或)
  - [一位二进制数按位或](#一位二进制数按位或)
  - [多位二进制数按位或](#多位二进制数按位或)
- [按位异或](#按位异或)
  - [一位二进制数按位异或](#一位二进制数按位异或)
  - [多位二进制数按位异或](#多位二进制数按位异或)
- [多个数字怎么计算](#多个数字怎么计算)
- [实用性质](#实用性质)
- [先算谁](#先算谁)
- [运算优先级陷阱](#运算优先级陷阱)

## 按位与

符号：`&`

使用方式：`a & b`

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位都是 `1`，置 `1`，如果有 `0`，置 `0`。  

- 对有符号二进制数，按照**补码**参与运算，结果也是**补码**（**大坑警告！**）。  

### 一位二进制数按位与

0 & 0 = 0  
0 & 1 = 0  
1 & 0 = 0  
1 & 1 = 1  

简记：**全 `1` 得 `1`，有 `0` 得 `0`**

（声明：不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 & 0 =", 0 & 0);
println("0 & 1 =", 0 & 1);
println("1 & 0 =", 1 & 0);
println("1 & 1 =", 1 & 1);
```

预期输出应该与上述规则一样：

```
0 & 0 = 0
0 & 1 = 0
1 & 0 = 0
1 & 1 = 1
```

### 多位二进制数按位与

**先转成补码，再从最低位开始，逐位求与。**

要求补码，一般先求**原码**，求原码的方式是：指定 m 位，先把数值部分转二进制，不足部分高位补 `0` 到 m-1 位，再确定符号位，正数是 `0` 负数是 `1`，加到最左边。

接着根据原码求补码：

- 对于正数，补码与原码相同。
- 对于负数，把原码的数值部分逐位取反加1。

然后才是从最低位开始逐位求与，注意对齐。

最后还要转回原数值：

如果符号位是0，直接转十进制即可；

如果符号位是1，与求补码类似，除了这一位以外，其余再逐位取反加1，得到原码，再把其余部分转十进制，符号位的 `1` 换成负号即可。

只有一个例外：符号位 1 其余全 0，则无原码，而且对应十进制数值等于 -2^(m-1)。

同时剩下一个疑问：m 取多少合适？

在不清楚用多少位补码的情况下，姑且按照数值大的确定补码，先保证位数够用。

例：计算 `11 & 5`。

转二进制补码：

11 是正数，用 4 位二进制数 `1011` 表示， 符号位 `0`，其余位不变，补码是 `01011`；

5 也是正数，二进制 `101`，只有 3 位，位数不够，先补一个 `0` 得到 `0101`，后续同理，得到补码 `00101`。

再计算：

`01011 & 00101 = 00001` （存疑？）

结果的符号位是 `0`，直接把数值部分转十进制即可，得到 1。

于是 `11 & 5 = 1`。

用代码计算一下：

```Processing
println(11&5);
```

查看控制台的输出，是 `1`。

也许你会说：直接转二进制，逐位求与，再转回十进制不一样吗？反正不足补 `0`：

`1011 & 0101 = 0001`

于是得到 1。

对正数，补码与原码相同，而且无论按位与、按位或还是按位异或，高位的 `0` 都不会影响结果。

但是对于负数就不可以，只能老老实实转补码计算。

例：计算 `11 & -5`。

转成补码······

问题是 -5 的补码是多少？有几位？

11 的二进制表示就有 4 位，加上一位 `0` 就有 5 位，为了保证位数够用，-5 的补码最少要有 5 位。

假设用 5 位有符号二进制数，用 `10101` 表示 -5，那么其补码就是 `11011`。

`01011 & 11011 = 01011 (?)` （注意这里存疑）

于是 `11 & -5 = 11`。

用代码计算一下：

```Processing
println(11&-5);
```

输出是 `11`，表明 5 位够了。

如果你忘记把负数转换成补码就可能得到这个结果：

`11 & -5 = 01011 & 10101 = 00001 = 1`

明显不对！而且你可能抓破头皮也找不出错在哪里。这就是最坑人的地方：

**计算机里面的数字按照补码参与位运算，结果也是补码**。

而且如果你在求十进制数 11 的二进制的时候，不小心多写了一位，把 `1011` 写成了 `11011`，那么 -5 的补码也不得不多用一位，变成了6位有符号二进制数补码：

`110101`

那么计算结果：

`011011 & 111011 = 011011`

即 `27 & -5`，结果 27，变大了不少。

用代码验证：

```Processing
println(0b11011 & -0b101, 27&-5);
```

输出 `27 27`。

忘记用补码运算，则有可能得到 `27 & -5 = 011011 & 100101 = 000001 = 1`，更离谱了。

那么有没有可能多补几个 `0` 就算出不同的结果？要一直补 `0` 补下去吗？有不用老是补 `0` 的方式吗？

### 32位补码够用了

其实用 32 位补码就可以一步到位，也不需要补更多 `0` 了。这是因为， `int` 类型整数默认 32 位有符号二进制数。  

之前的“一位二进制数”和“多位二进制数”只是为了便于阅读人为分出来的，实际上计算机里用了多少位二进制数来表示，就是多少位二进制数，而且都是最坑人的补码。

于是一个小小的只有两个字符的 -5，其补码有整整 32 个 `0` 和 `1`。

为了便于阅读，每 4 位用空格分开，下同：
```
1111 1111 1111 1111 1111 1111 1111 1011
```
类似的，27 的补码：
```
0000 0000 0000 0000 0000 0000 0001 1011
```
于是 `27 & -5` 实际上计算的是：
```
  1111 1111 1111 1111 1111 1111 1111 1011
& 0000 0000 0000 0000 0000 0000 0001 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0001 1011
```
得到正数，原码与补码相同，从而结果还是 27。  

这里为了书写方便，就仿照一般竖式计算加减乘法的方式这样写，只是更换了运算符，运算规则，以及使用的是二进制数而不是十进制数，以及中间每四位就留出空格便于对齐每一位。我没查过这种写法是否有人使用过。

同时提醒一句，如果你还想模仿这种书写方式，为了与其他字符区分，可以使用'bitand'、'bitor'、'bitxor'或者汉字“位与”、“位或”、“位异或”：

`27 & -5`

```
       1111 1111 1111 1111 1111 1111 1111 1011
bitand 0000 0000 0000 0000 0000 0000 0001 1011
----------------------------------------------
       0000 0000 0000 0000 0000 0000 0001 1011
```

```
    1111 1111 1111 1111 1111 1111 1111 1011
位与 0000 0000 0000 0000 0000 0000 0001 1011
-------------------------------------------
    0000 0000 0000 0000 0000 0000 0001 1011
```

Markdown 里的字符一般足以区分，故可以接着使用 `&`、`|`、`^` 等符号，看起来还简洁一点。

类似地，`11 & -5`：
```
  1111 1111 1111 1111 1111 1111 1111 1011
& 0000 0000 0000 0000 0000 0000 0000 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1011
```
结果是 11。

`11 & 5`：

```
  0000 0000 0000 0000 0000 0000 0000 0101
& 0000 0000 0000 0000 0000 0000 0000 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 0001
```

结果还是 1，与之前计算的一致。  

甚至可以求一下 `-11 & -5`：
```
  1111 1111 1111 1111 1111 1111 1111 0101
& 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0001
```
得到 -15。  

不过一般列出完整的 32 位补码，工作量确实有点大，也许你会忽略打头的 `0`，反正不足用 `0` 补齐嘛······  

但是隐藏的大坑就在这里：**由于计算机里的数是补码，所有负数的二进制表示都是以 `1` 开头的，不足位也都是 `1`。**所以遇到负数还能省略高位吗？能，但是默认不再是 `0` 而是 `1`。

简记：**为了避免出错，在用补码计算位运算省略高位的时候，符号位是什么，省略的就是什么，补齐就要用什么。即正数默认高位 `0`，负数默认高位 `1`，如果位数不够，正数用 `0` 补齐，负数用 `1` 补齐。**

这样不仅不用补那么多个 `0` 了，还有一个好处：如果用 Python 计算位运算，在省略高位数字的情况下，就不用费尽心思考虑到底要用多少位补码才不会出错了。毕竟 Python 里面 `-11&-5` 的结果也是（用补码求出的） -15。

## 按位或

符号：`|`

使用方式：`a | b`  

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位有1，置1，如果都是0，置0。  

- 对有符号二进制数，按照补码参与运算，结果也是补码。

### 一位二进制数按位或

0 | 0 = 0  
0 | 1 = 1  
1 | 0 = 1  
1 | 1 = 1  

简记：**有 `1` 得 `1`，全 `0` 得 `0`**

（同理，不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 | 0 =", 0 | 0);
println("0 | 1 =", 0 | 1);
println("1 | 0 =", 1 | 0);
println("1 | 1 =", 1 | 1);
```

预期输出应该与上述规则一样：

```
0 | 0 = 0
0 | 1 = 1
1 | 0 = 1
1 | 1 = 1
```

### 多位二进制数按位或

**先转成补码，再从最低位开始，逐位求或**。

例如，计算：

11 | 5 = ?  
11 | -5 = ?  
-11 | 5 = ?  
-11 | -5 = ?  

展开成32位补码：

```
11 | 5
  0000 0000 0000 0000 0000 0000 0000 1011
| 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1111
得到 11
```

```
11 | -5
  0000 0000 0000 0000 0000 0000 0000 1011
| 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 1011
得到 -5
```

```
-11 | 5
  1111 1111 1111 1111 1111 1111 1111 0101
| 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0101
得到 -11
```

```
-11 | -5
  1111 1111 1111 1111 1111 1111 1111 0101
| 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 1111
得到 -1
```

用以下代码验证一下：

```Processing
println("11 | 5 =", 11 | 5);
println("11 | -5 =", 11 | -5);
println("-11 | 5 =", -11 | 5);
println("-11 | -5 =", -11 | -5);
```

预期输出：
```
11 | 5 = 15
11 | -5 = -5
-11 | 5 = -11
-11 | -5 = -1
```

## 按位异或

符号：`^` 

使用方式：`a ^ b`

计算规则：

- 对无符号二进制数，输出的每一位，如果参与运算两数的相应位不同，置1，如果相同0，置0。  

- 对有符号二进制数，按照补码参与运算，结果也是补码。

### 一位二进制数按位异或

0 ^ 0 = 0  
0 ^ 1 = 1  
1 ^ 0 = 1  
1 ^ 1 = 0  

简记：**不同得 `1`，相同得 `0`**

（同理，不要问我这种口诀是谁先想出来的，我也不知道）

用以下代码验证一下：

```Processing
println("0 ^ 0 =", 0 ^ 0);
println("0 ^ 1 =", 0 ^ 1);
println("1 ^ 0 =", 1 ^ 0);
println("1 ^ 1 =", 1 ^ 1);
```

预期输出应该与上述规则一样：

```
0 ^ 0 = 0
0 ^ 1 = 1
1 ^ 0 = 1
1 ^ 1 = 0
```

### 多位二进制数按位异或

**先转成补码，再从最低位开始，逐位求异或**。

还是之前的例子，只不过换成异或：

11 ^ 5 = ?  
11 ^ -5 = ?  
-11 ^ 5 = ?  
-11 ^ -5 = ?  

展开成32位补码：

```
11 ^ 5
  0000 0000 0000 0000 0000 0000 0000 1011
^ 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1110
得到 14
```

```
11 ^ -5
  0000 0000 0000 0000 0000 0000 0000 1011
^ 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0000
得到 -16
```

```
-11 ^ 5
  1111 1111 1111 1111 1111 1111 1111 0101
^ 0000 0000 0000 0000 0000 0000 0000 0101
-----------------------------------------
  1111 1111 1111 1111 1111 1111 1111 0000
得到 -16
```

```
-11 ^ -5
  1111 1111 1111 1111 1111 1111 1111 0101
^ 1111 1111 1111 1111 1111 1111 1111 1011
-----------------------------------------
  0000 0000 0000 0000 0000 0000 0000 1110
得到 14
```

用以下代码验证一下：

```Processing
println("11 ^ 5 =", 11 ^ 5);
println("11 ^ -5 =", 11 ^ -5);
println("-11 ^ 5 =", -11 ^ 5);
println("-11 ^ -5 =", -11 ^ -5);
```

预期输出：

```
11 ^ 5 = 14
11 ^ -5 = -16
-11 ^ 5 = -16
-11 ^ -5 = 14
```

## 多个数字怎么计算

从左往右依次计算即可。

如果不想依次计算，也有偷懒的办法，先求补码，一行放一个，每一列对齐，然后按照你喜欢的顺序逐列计算即可，不存在进位与借位问题，计算方式是：

- 多个数字按位与：对每一位，无论有多少个数字，**全 `1` 得 `1`，有 `0` 得 `0`**。
- 多个数字按位或：对每一位，**有 `1` 得 `1`，全 `0` 得 `0`**。
- 多个数字按位异或：有所不同，对每一位，**奇数个 `1` 得 `1`，偶数个 `1` 得 `0`**。

为什么呢？

- 多个数字按位与：对每一位，无论有多少个数字，如果全是 `1` ，结果相应位就是 `1`；只要发现了一个 `0`，无论后面是什么数字，结果相应位都是 `0`。即**全 `1` 得 `1`，有 `0` 得 `0`**。
- 多个数字按位或：对每一位，只要发现了一个 `1`，无论后面是什么数字，结果相应位都是 `1`；到最后一个数字也没发现 `1`，即全是 `0` 的时候，结果相应位才是 `0`。即**有 `1` 得 `1`，全 `0` 得 `0`**。
- 多个数字按位异或：有所不同。不难得出，对每一位，和 `0` 按位异或不影响结果相应位的值，故只需要关注 `1` 的个数。而和 `1` 按位异或两次也不改变结果相应位的数值。从而如果第一个数字相应位是 `0`，则后面有奇数个 `1` 得 `1`，偶数个 `1` 得 `0` ；如果第一个数字相应位是 `1`，则后面有奇数个 `1` 得 `0`，偶数个 `1` 得 `1`。合并两种情况，得到结论**奇数个 `1` 得 `1`，偶数个 `1` 得 `0`**。

同时说明，按位与、按位或、按位异或，都满足**结合律**，先算前两个数还是先算后两个数不影响结果。

进一步地，根据一位二进制数位运算规则，无论是按位与、按位或还是按位异或，不难验证，交换参与运算的两个数字位置，结果不变。而多位二进制数是按照补码逐位计算的，交换位置又不改变原数字具体每一位的数值，从而结果每一位都不变，满足**交换律**。

从而**按位与、按位或、按位异或的运算结果与运算顺序无关，你可以任意选择运算顺序**。

举个例子，分别计算 1789569706，-858993460，-252645136，-16711936，-65536 这五个数字按位与、按位或、按位异或的结果。  

先求每个数字的补码，从最低位对齐，得到：

```
1789569706: 0110 1010 1010 1010 1010 1010 1010 1010
-858993460: 1100 1100 1100 1100 1100 1100 1100 1100
-252645136: 1111 0000 1111 0000 1111 0000 1111 0000
-16711936:  1111 1111 0000 0000 1111 1111 0000 0000
-65536:     1111 1111 1111 1111 0000 0000 0000 0000
```
显然，参与运算的 5 个数字的二进制补码，只有最左边第二位都是 `1`，从而按位与的结果也只有这一位是 `1`，得到：
```
&:          0100 0000 0000 0000 0000 0000 0000 0000
```
即 1073741824。

而按位或，只有最右边全是 `0`，其余每一列都有 `1`，从而结果也只有最右边是 `0`，得到：
```
|:          1111 1111 1111 1111 1111 1111 1111 1110
```
即 -2。

至于按位异或，从左往右每一列，仔细数一数，`1` 的数量分别是：4，5，4，3，4，3，3，2，······，于是得到：
```
^:          0101 0110 0110 1001 0110 1001 1001 0110
```
即 1449748886。

考虑到徒手计算确实比较烦琐，实际一般用代码计算：

```Processing
int a = 1789569706;
int b = -858993460;
int c = -252645136;
int d = -16711936;
int e = -65536;
int result1 = a & b & c & d & e;
int result2 = a | b | c | d | e;
int result3 = a ^ b ^ c ^ d ^ e;
println(result1, result2, result3);
```
预期输出：
```
1073741824 -2 1449748886
```

## 实用性质

由一位二进制数的位运算规则，不难得出，无论什么数字，对补码的每一位，都满足：

- 和 `0` 按位与，得到 `0`；和 `1` 按位与，不变。
- 和 `0` 按位或，不变；和 `1` 按位或，得到 `1`。
- 和 `0` 按位异或，不变；和 `1` 按位异或，取反。

于是利用位运算就可以设置二进制数的特定数位。

再加上 `0` 的补码全 `0`，-1 的补码全 `1`，从而任何数字，都有：

- 和 0 按位与得到 0，和 -1 按位与不变。
- 和 0 按位或不变，和 -1 按位或得到 -1。
- 和 0 按位异或不变，和 -1 按位异或就是把每一位取反。

这样就有了通过位运算把所有位置 `1`，以及把所有位清 `0` 的方式。

同时不难发现，按位与倾向于减少结果中 `1` 的个数，按位或倾向于增加结果中 `1` 的个数。

按位与、按位或、按位异或，满足交换律和结合律，结果与运算顺序无关。

由前面的例子不难看出，尽管补码的最高位常常叫做**符号位**，但是实际的位运算，无论是按位与，按位或，还是按位异或，在逐位计算的时候对所有位都是**一视同仁，不区分符号位**。

从而无论多少个数字按位与，只要有正数，结果就是正数；无论多少个数字按位或，只要有负数，结果就是负数。

## 先算谁

让我们看一看不同位运算同时出现在一个算式里面怎么计算。

首先是按位与和按位或同时出现：

2 | 4 & 5 = ？  
5 & 4 | 2 = ？  

如果先计算按位与，即 2 | (4 & 5)，(5 & 4) | 2，都会得到 6；    
如果先计算按位或，即 (2 | 4) & 5，5 & (4 | 2)，都会得到 4。  

实际结果都是 6。

不妨用代码验证一下：
```Processing
int a1 = 2 | 4 & 5;
int a2 = 5 & 4 | 2;
println(a1, 2 | (4 & 5), a1 == (2 | (4 & 5)), a2, (5 & 4) | 2, a2 == ((5 & 4) | 2));  // 与先算按位与的结果是否相等
println(a1, (2 | 4) & 5, a1 == ((2 | 4) & 5), a2, 5 & (4 | 2), a2 == (5 & (4 | 2)));  // 与先算按位或的结果是否相等
```
得到：
```
6 6 true 6 6 true
6 4 false 6 4 false
```
也就是说，**Processing 中，按位与的优先级高于按位或**。

然后是按位与和按位异或同时出现：

2 ^ 4 & 5 = ？  
5 & 4 ^ 2 = ？  

如果先计算按位与，即 2 ^ (4 & 5)，(5 & 4) ^ 2，都会得到 6；    
如果先计算按位异或，即 (2 ^ 4) & 5，5 & (4 ^ 2)，都会得到 4。  

实际结果也都是 6。

不妨用代码验证一下：
```Processing
int a1 = 2 ^ 4 & 5;
int a2 = 5 & 4 ^ 2;
println(a1, 2 ^ (4 & 5), a1 == (2 ^ (4 & 5)), a2, (5 & 4) ^ 2, a2 == ((5 & 4) ^ 2));  // 与先算按位与的结果是否相等
println(a1, (2 ^ 4) & 5, a1 == ((2 ^ 4) & 5), a2, 5 & (4 ^ 2), a2 == (5 & (4 ^ 2)));  // 与先算按位异或的结果是否相等
```
得到：
```
6 6 true 6 6 true
6 4 false 6 4 false
```
也就是说，**Processing 中，按位与的优先级高于按位异或**。

于是在按位与、按位或、按位异或中，按位与具有最高的优先级。

接着是按位或和按位异或同时出现：

7 ^ 6 | -1 = ？  
-1 | 6 ^ 7 = ？  

如果先计算按位或，即 7 ^ (6 | -1)，(-1 | 6) ^ 7，都会得到 -8；
如果先计算按位异或，即 (7 ^ 6) | -1，-1 | (6 ^ 7)，都会得到 -1。

实际结果都是 -1。

继续，代码验证：
```Processing
int a1 = 7 ^ 6 | -1;
int a2 = -1 | 6 ^ 7;
println(a1, 7 ^ (6 | -1), a1 == (7 ^ (6 | -1)), a2, (-1 | 6) ^ 7, a2 == ((-1 | 6) ^ 7));  // 与先算按位或的结果是否相等
println(a1, (7 ^ 6) | -1, a1 == ((7 ^ 6) | -1), a2, -1 | (6 ^ 7), a2 == (-1 | (6 ^ 7)));  // 与先算按位异或的结果是否相等
```
得到：
```
-1 -8 false -1 -8 false
-1 -1 true -1 -1 true
```
也就是说，**Processing 中，按位异或的优先级高于按位或**。

结论：**Processing 中，这三种位运算的优先级是，先算按位与，再算按位异或，然后按位或**。

## 运算优先级陷阱

让我们再看一看位运算（这里只有按位与，按位或，按位异或，下同）与其他运算符出现在一个算式中会发生什么。

由于按位与运算优先级高于按位异或和按位或，从而比按位与优先级更高的运算符，优先级也高于按位或和按位异或。

首先是正负号 `+`、`-`。显然一个 `+`不改变数值，忽略。至于 `-`，从前面的例子也能看出来，无论负号在按位与、按位或、按位异或运算的开头还是中间，都是包含在补码里面（并且逐位取反加 1）了，得到的结果都与没有负号时不尽相同，从而优先级是：`-` > `&`、`^`、`|`。

然后是加、减运算 `+`、`-`，优先级也高于按位与：

1 & 4 + 3 & 2 = 1 & (4 + 3) & 2 = 1 & 7 & 2 = 0  
1 & 4 - 3 & 2 = 1 & (4 - 3) & 2 = 1 & 1 & 2 = 0  

假设先算按位与则分别得到 2，-2。

用代码计算一下：
```Processing
println(1 & 4 + 3 & 2, 1 & (4 + 3) & 2, (1 & 4) + (3 & 2));
println(1 & 4 - 3 & 2, 1 & (4 - 3) & 2, (1 & 4) - (3 & 2));
```

得到：
```Processing
0 0 2
0 0 -2
```

验证了优先级：**Processing 里面，加减法高于按位与**。

至于乘 `*`、除 `/`、模运算 `%`，优先级高于加减法，自然就高于按位与。

所以如果要先计算 `&`、`^`、`|`，再求和差乘积等，**要么分开计算，要么打括号**。

接着是关系运算符 `<`、`<=`、`>`、`>=`，以及等于 `==`，不等于 `!=`。幸运的是，Processing 里面，直接把 `<`、`<=`、`>`、`>=`、 `==`、`!=` 和 `&`、`^`、`|` 放进同一个算式里面**会报错**。
例如：
```Processing
println(3 & 3 == 1 & 4);
```
输出的报错信息：`The operator & is undefined for the argument type(s) int, boolean`

你不得不加括号才能避免报错，这就避免了可能的陷阱，同时也是前面的这类例子都加了括号的原因。

同时可以发现 `int` 类型和 `boolean` 类型是不同的，Processing 里面你不能把整数当布尔值来用，像什么 `while(0){}`，`if(1){}` 都会报错，逻辑运算符 `&&`、`||`、`!` 也不能用于整数，而 `&`、`^`、`|` 也不接受布尔值。

至于各种赋值运算，默认优先级低于 `&`、`^`、`|`，如果强行加括号先赋值再算其他，也不是 `println()` 之类的函数里面，例如 `int s = 0; (s |= 3) ^ 1;` 同样会报错，不容易遇到问题。

于是目前发现的 `&`、`^`、`|` 优先级最大的陷阱不是和关系运算逻辑运算同时出现，而是**和算术运算同时出现，先算算术运算再算 `&`、`^`、`|`**。

结论：**Processing 里面，算术运算比 `&`、`^`、`|` 先算，而 `&`、`^`、`|` 与涉及 `boolean` 类型的运算符同时出现，必须加括号，否则报错。**
