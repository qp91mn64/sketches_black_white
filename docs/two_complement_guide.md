# 补码怎么求（详细版）

- [求补码](#求补码)
- [已知补码求原码](#已知补码求原码)
- [补码范围和无原码陷阱](#补码范围和无原码陷阱)
- [m位补码范围公式](#m位补码范围公式)
- [Processing的32位补码](#Processing的32位补码)
- [小结](#小结)

## 求补码

给定十进制数，要求二进制补码，一般先求二进制**原码**，方式是：先转成二进制，再在最左边加上**符号位**，正数置 `0` 负数置 `1`。

等等，怎么还有个符号位？转二进制数不是直接转吗？

这是由于计算机只认 `0` 和 `1`，符号也必须用 `0` 或 `1` 表示。与一般带符号数字一样，有符号二进制数的符号也在最左边，只是也是 `0` 或者 `1`，就占去一位，又称符号位。符号位的有无是一般二进制数字与二进制原码的主要区别。

然后根据原码求**补码**，一种计算方式如下：

**对有符号二进制数，正数的补码等于原码，负数的补码，符号位不变，其余逐位取反加 1**。  

其中逐位取反得到的中间结果也叫**反码**，只是个人感觉除了作为中间过程以外，很少用到。如果一步求补码有点困难，尤其是32位或更多位的补码，你完全可以分成两步计算。

以 4 位有符号二进制数字为例，对于十进制数字 3，原码是 `0011`，正数，补码与原码相同是 `0011`。  
而对于十进制数字 -3，原码是 `1011`，负数，最左边的符号位不变，其余逐位取反得到 `1100`，加 1 得到 `1101`，于是 -3 的补码是 `1101`。

那么如何根据补码求原码呢？

## 已知补码求原码

对于正数，原码就等于补码。  

对于负数，一般可以继续按照取补码的方式，最左边不动，其余逐位取反加 `1` 就能得到原码。  

例如 `1101` ，符号位是 `1`，负数，不动，其余逐位取反得到 `1010`，再加 1 得到 `1011`，恰好对应 -3。

简记：**补码的补码等于原码**。

但是有个坑：**补码的最小值除外，它没有对应的原码。**

## 补码范围和无原码陷阱

还是以 4 位有符号二进制数字为例，最小能表示 -8 ，对应补码 `1000`，如果按照求原码的方式，最左边不动，其余逐位取反得到`1111`，再加 `1` 就溢出了，`0000` 对应 0，没办法求。而且 4 位二进制数原码最小只能表示 -7，用 `1111` 表示，你想要 -8，不好意思，至少也要 5 位的 `11000`。

为什么呢？
让我们列出4位有符号二进制数所有的原码和补码看下到底哪里出了幺蛾子：

|十进制数值|原码|补码|
|--|--|--|
|+7|`0111`|`0111`|
|+6|`0110`|`0110`|
|+5|`0101`|`0101`|
|+4|`0100`|`0100`|
|+3|`0011`|`0011`|
|+2|`0010`|`0010`|
|+1|`0001`|`0001`|
|+0|`0000`|`0000`|
|-0|`1000`|`0000`|
|-1|`1001`|`1111`|
|-2|`1010`|`1110`|
|-3|`1011`|`1101`|
|-4|`1100`|`1100`|
|-5|`1101`|`1011`|
|-6|`1110`|`1010`|
|-7|`1111`|`1001`|
|-8|不存在|`1000`|

仔细比较一下可以发现：

- 原码表示范围是 -7 到 +7，补码表示范围是 -8 到 +7。

- 除了 0 以外，其余每个数值都分别与原码、补码一一对应。  

- 对于 0，原码竟然分出了正负，分别用 `0000` 和 `1000` 表示，而补码只用了一组 `0000` 就能表示（反直觉的是它们二者看起来不同，对应的数值竟然相同，且原码不同，补码又相同），于是剩下一组 `1000` 可以**多表示一个数值 -8**。  

于是求 -8 的补码不能使用之前给出的常用计算方式，否则溢出得到 `0000`是 +0 的原码，实际上直接写个 `1` 后面跟 3 个 `0` 就好了；已知 -0 的原码 `1000` 求补码，如果除了符号位逐位取反加1，溢出得到 `0000`，与原码 `0000` 的补码相同。

又如两位有符号二进制数：

|十进制数值|原码|补码|
|--|--|--|
|+1|`01`|`01`|
|+0|`00`|`00`|
|-0|`10`|`00`|
|-1|`11`|`11`|
|-2|不存在|`10`|

类似地，原码表示范围 -1 到 +1，而且 `10` 和 `00` 都表示数值 0；补码表示范围 -2 到 +1，且 -2 的补码 `10` 无原码。

三位有符号二进制数：

|十进制数值|原码|补码|
|--|--|--|
|+3|`011`|`011`|
|+2|`010`|`010`|
|+1|`001`|`001`|
|+0|`000`|`000`|
|-0|`100`|`000`|
|-1|`101`|`111`|
|-2|`110`|`110`|
|-3|`111`|`101`|
|-4|不存在|`100`|

类似地，原码表示范围 -3 到 +3，而且 `100` 和 `000` 都表示数值 0；补码表示范围 -4 到 +3，且 -4 的补码 `100` 无原码。

限于篇幅，就不列出更多数位的情况了。不过如果只有 1 位有符号二进制数，那么唯一一位就是符号位，不再存在数值位，很难说有什么实际意义。  

## m位补码范围公式

那么假设有 m 位有符号二进制数，原码和补码的表示范围是多少？最坑人的无原码的补码又对应数值几呢？

显然，原码与补码都能表示0，也都能表示一片连续整数，而且有限位数只能表示有限个整数，必然存在能表示的最小值和最大值。

继续比较上面列出的结果：

|m的值|原码最小值|原码最大值|补码最小值|补码最大值|只存在补码的数值|
|--|--|--|--|--|--|
|2|-1|1|-2|1|-2|
|3|-3|3|-4|3|-4|
|4|-7|7|-8|7|-8|
|...|...|...|...|...|...|

有耐心的甚至可以多列出几行，再找规律。  

容易发现：
- 对相同的m值，“原码最小值”与“原码最大值”的绝对值相同，符号相反；
- 原码最大值等于补码最大值；
- 补码最小值恰好比原码最小值少 1，而且少的那个数就是只存在补码的数值；

进一步观察：
- 只存在补码的数值，恰好对应 2 的幂的相反数，于是等于 $-2^{m-1}$
- 相应地，补码最小值等于 $-2^{m-1}$，最大值等于 $2^{m-1}-1$
- 相应地，原码最小值等于 $1-2^{m-1}$，最大值等于 $2^{m-1}-1$

此外可以发现，只存在补码的那个数值，补码都是 `1` 开头后面一串 `0`，而且 m 位二进制数有 m-1 个 `0`。

即：**m 位有符号二进制数，原码表示范围是 $1-2^{m-1}$ 到 $2^{m-1}-1$ 之间，补码表示范围是 $-2^{m-1}$ 到 $2^{m-1}-1$ 之间，数值 $-2^{m-1}$ 只存在补码，且该补码符号位是 `1` 其余 m-1 位是 `0`。**

另一种理解方式：  

m 位有符号二进制数，一共 $2^m$ 个，无论原码，补码，最多都只能表示 $2^m$ 个不同的数。  

对于原码，正负对称，而且 +0 和 -0 用了不同数码 `0000` 以及 `1000` 表示，于是最多只能表示 $2^m-1$ 个不同的数，其中正数和负数都有 $2^{m-1}-1$ 个，则表示范围是 $1-2^{m-1}$ 到 $2^{m-1}-1$ 之间；  

对于补码，由于+0和-0只用一个数码 `0000` 表示，节省出一个数码 `1000`，能多表示一个，分给负数 $-2^{m-1}$，则表示范围是 $-2^{m-1}$ 到 $2^{m-1}-1$ 之间，同时 $-2^{m-1}$ 就只存在补码不存在原码，其补码的符号位是 `1`，剩下 m-1 位都是  `0`。

总之，对于不同位数的有符号二进制数，取补码的规则大同小异，而且补码也都能多表示一个数值。  

## Processing 的 32 位补码

**声明：默认 Processing 4，没在所有版本上测试不保证所有细节适用于其他版本。**

Processing 里面的整数默认 `int` 类型，是 32 位补码，表示范围是 -2^31 到 2^31-1 之间，即 -2147483648 到 2147483647 之间。  

例如，十进制整数 0，1，2411，-1，-82164，对应的二进制原码（为了便于阅读，每 4 位一个空格隔开）分别是：

0000 0000 0000 0000 0000 0000 0000 0000  
0000 0000 0000 0000 0000 0000 0000 0001  
0000 0000 0000 0000 0000 1001 0110 1011  
1000 0000 0000 0000 0000 0000 0000 0001  
1000 0000 0000 0001 0100 0000 1111 0100  

正数和 0 的补码不动，负数补码按照最左边符号位不动，其余逐位取反加 1 计算，得到：

0000 0000 0000 0000 0000 0000 0000 0000  
0000 0000 0000 0000 0000 0000 0000 0001  
0000 0000 0000 0000 0000 1001 0110 1011  
1111 1111 1111 1111 1111 1111 1111 1111  
1111 1111 1111 1110 1011 1111 0000 1100  

Processing 里面，有一个函数 `binary()`，看名称是把整数转二进制，实际上得到的是补码形式的 32 位二进制字符串，即求补码用的。

注意与 `Integer.toBinaryString()` 或 `Integer.toString(n,2)` （其中 `n` 是个 `int` 类型整数）相区分，前者对正数只保留最后有 1 的部分，对负数显示完整的 32 位补码；后者既不会显示完整的 32 位补码，也不会处理负号。

还是刚才的那几个整数，代入 `binary()` 试一试：

```Processing
println(binary(0));
println(binary(1));
println(binary(2411));
println(binary(-1));
println(binary(-82164));
```

分别输出：
```
00000000000000000000000000000000
00000000000000000000000000000001
00000000000000000000100101101011
11111111111111111111111111111111
11111111111111101011111100001100
```

是的，整整 32 个 `0` 和 `1`，而且都是补码形式。与前面求的补码仔细对比一下，两者一样。这么多 `0` 和 `1` 看多了真的会让人头大，还好直接用 `println()` 得到的数字就是十进制，而且没有这么多位。

## 小结

原码与无符号二进制数字的区别在于：原码的最高位是符号位，正数是 `0`，负数是 `1`。

已知十进制数求原码的方式是：先确定符号位，再把数值部分转二进制作为其余部分。

根据原码求补码的方式：正数的补码等于原码，负数的补码，符号位不变，其余逐位取反加 1。

补码的补码等于原码，除了补码的最小值无原码。

m 位有符号二进制数，原码表示范围是 $1-2^{m-1}$ 到 $2^{m-1}-1$ 之间，补码表示范围是 $-2^{m-1}$ 到 $2^{m-1}-1$ 之间，数值 $-2^{m-1}$ 只存在补码，且该补码符号位是 `1` 其余 m-1 位是 `0`。

Processing 里面的整数一般用 `int` 类型，是 32 位补码表示的，表示范围是  -2147483648 到 2147483647 之间。

Processing 求补码可以用 `binary()`，默认返回 32 位二进制字符串。
