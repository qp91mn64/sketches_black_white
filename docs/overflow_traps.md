# Processing 4 的溢出陷阱

- [正数加正数变成负数](#正数加正数变成负数)
- [负数加负数变成正数](#负数加负数变成正数)
- [非0数相乘得到0](#非0数相乘得到0)

## 正数加正数变成负数

有一个隐藏的大坑，只有露出二进制补码形式的“庐山真面目”才能弄明白：  

**如果正数加在一起太大，超过了 `int` 类型的大小限制 2147483647，就会变成负数，从 -2147483648 开始往上加剩余部分。**

尤其是如果你以前没学过编程，或者习惯了 Python 这种不限制整数大小的编程语言，突然遇到正数加正数变成负数，真是丈二和尚——摸不着头脑。  

最关键的是，Processing 里面正数加上正数它真的就有可能莫名其妙变成负数，其中 `binary()` 用于求 32 位补码：

```Processing
println(binary(2147483647));  // int类型数字的最大值2^32-1
println(binary(2147483647+1));  // 不是+2147483648，最高位已经是符号位了！
println(binary(-2147483648));   // int类型数字的最小值-2^32，这是由于补码能多表示一个数字
println(2147483647+1==-2147483648);  // 大坑。最反直觉的地方。只是不要尝试三个连等号，会报错。
```

会分别输出：

```
01111111111111111111111111111111
10000000000000000000000000000000
10000000000000000000000000000000
true
```

还有更奇葩的。既然“正正得负”了，那么负数加负数会不会“**负负得正**”？？  

## 负数加负数变成正数

关键是还真的会。似乎这个也是溢出？

```Processing
println(binary(-2147483648));
println(binary(-1));
println(binary(-2147483648-1));
println(binary(2147483647));
println(-2147483648-1==2147483647);  // true又出现了
```
输出：
```
10000000000000000000000000000000
11111111111111111111111111111111
01111111111111111111111111111111
01111111111111111111111111111111
true
```

结论：**Processing 里的整数用有符号二进制数的补码参与运算，而且进位到符号位，就会莫名其妙地改变符号。**

## 非0数相乘得到0

对整数除法，越除越接近 0，不会出现溢出。

那么整数乘法呢？

一样的，溢出部分会从 -2147483648 开始加上剩余部分，就好像以 2 的 32 次幂 4294967296 为一个周期一样。

注意不要用 `pow()`，这个函数默认返回浮点数，如果是 `int(pow())`，超出的部分会被截断，而不是从另一边继续计算。

可以用 2 的 30 次幂 1073741824 的整数倍检验一下：

```Processing
for (int i = -4 ; i <= 4; i++) {
  println(1073741824,'x', i, '=', 1073741824 * i,',',-1073741824,'x', i, '=', -1073741824 * i);
}
```
输出：
```
1073741824 x -4 = 0 , -1073741824 x -4 = 0
1073741824 x -3 = 1073741824 , -1073741824 x -3 = -1073741824
1073741824 x -2 = -2147483648 , -1073741824 x -2 = -2147483648
1073741824 x -1 = -1073741824 , -1073741824 x -1 = 1073741824
1073741824 x 0 = 0 , -1073741824 x 0 = 0
1073741824 x 1 = 1073741824 , -1073741824 x 1 = -1073741824
1073741824 x 2 = -2147483648 , -1073741824 x 2 = -2147483648
1073741824 x 3 = -1073741824 , -1073741824 x 3 = 1073741824
1073741824 x 4 = 0 , -1073741824 x 4 = 0
```

最反直觉的事情出现了：**两个非零数字相乘得到了 0** **!** 怎么可能！到底哪里出了问题？是不是有 Bug？
```Processing
println(1073741824*4==0);
```
输出：
```
true
```
就是实实在在的 0 ！溢出之后变成 0 了！

这种情况之前我只在模运算（或者，不怕数学的，模 m 剩余类环，此处由于篇幅所限不再赘述，请自行查资料）里面见到过类似的，可以理解为把整数除以 `m` 取余数，只有 0、1、2、...、m-1 个不同的可能数字，把这 m 个数字组成集合，定义与一般整数类似的加法和乘法，结果溢出就对 m 取余数，例如 `m=4` 时，2 的 2 倍得到 4，溢出了，对 4 取余数，得到 0。可以参考我的另一个 Processing 代码仓库 sketches_numbers 里面画整数倍的代码，看一看哪些 m 会导致先乘以整数倍再对 m 取余数，还没乘到 m 倍就有部分整数提前得到 0。

同理，Processing 里面的 `int` 类型整数，补码，有一点像模 `m = 4294967296` 的情形，即 2 的 32 次幂，溢出之后仍然对 m 取模使其落在可能的数字范围里，但是最大的区别是可能的数字范围是 -2147483648 到 2147483647 而不是 0 到 4294967295，而且**不能简单视为从 0 到 4294967295 的之间的一个数字减去 2147483648 再按照与新的零值的差值计算**，对加法，两个一半得到模的值恰好抵消，没事，对乘法就可能出错： 

假设范围是从 0 到 4294967295，则*第 2147483650 个整数* 2147483649 乘以*第 2147483652 个整数* 2147483651，对 4294967296 取模，等于*第 4 个整数* 3。但是如果先减 2147483648，以得到 -2147483648 到 2147483647 之间的数字，分别是 1 和 3，再相乘得到 3，是*第 2147483652 个整数*，看起来也是 3，但是不要忘了还要再加回去，从而最终得到 2147483651，不再得到 3，整整差了模的一半。

结论：**Processing 里面的 `int` 类型整数都是二进制补码，计算时，一旦溢出，会导致意料之外的结果。**

这就是整数计算最坑人的地方，也是其它系列的代码里面不建议 `offset` 设置太大（`BigInteger` 除外）的原因。
